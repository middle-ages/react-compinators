import {Unstyled} from "@storybook/blocks"
import {pipe, String} from 'effect'
import {
  assumeProp,
  assumeProps,
  modProp,
  mapProp,
  mapProps,
  omitProps,
  unfoldProp
} from 'react-compinators'

<Unstyled>

<h1><span style={{fontFamily: 'Times New Roman, Times, serif'}}>λ⚛</span> React Compinators Tutorial</h1>

<ol>
  <li><a href="#running-example"><code>Running Example</code></a></li>
  <li><a href="#assume"><code>Assume</code></a></li>
  <ol>
    <li><a href="#1-assumeprops"><code>assumeProps</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/assumeProps.html">API</a>)</li>
    <li><a href="#2-assumeprop"><code>assumeProp</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/assumeProp.html">API</a>)</li>
    <li><a href="#3-unfoldprop"><code>unfoldProp</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/unfoldProp.html">API</a>)</li>
  </ol>
  <li><a href="#map"><code>Map</code></a></li>
  <ol>
    <li><a href="#1-modprop"><code>modProp</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/modProp.html">API</a>)</li>
    <li><a href="#2-mapprops"><code>mapProps</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/mapProps.html">API</a>)</li>
    <li><a href="#3-mapprop"><code>mapProp</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/mapProp.html">API</a>)</li>
    <li><a href="#4-omitprops"><code>mapProps</code></a> (<a href="https://middle-ages.github.io/react-compinators-docs/docs/functions/omitProps.html">API</a>)</li>
  </ol>
  <li><a href="#a-note-about-displayname">A note about <code>displayName</code></a></li>
</ol>

## Running Example

A simple label component we will use as a running example:
```tsx
export const COLORS = ['red', 'yellow', 'green'] as const
export type Color = (typeof COLORS)[number]

interface LabelProps { text: string; color: Color }

const Label = ({text, color: background}: LabelProps) => (
  <div style={{background}}>{text}</div>
)

<Label text="Green"  color="green" />
<Label text="Yellow" color="yellow" />
<Label text="Red"    color="red" />
```

export const COLORS = ['red', 'yellow', 'green']
export const Label = ({text, color: background}) => (
  <div style={{background, textAlign: 'center'}}>{text}</div>
)

<fieldset>
<legend>Three Labels</legend>
<Label text="Green"  color="green" />
<Label text="Yellow" color="yellow" />
<Label text="Red"    color="red" />
</fieldset>

## The Combinators

### Assume

#### 1. `assumeProps`

To partially apply a subset of the `<Label>` props, we can use
`assumeProps`(_base_)(partial props):
```tsx
import {assumeProps} from 'react-compinators'

const YellowLabel = assumeProps(Label)({color: 'yellow'})

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // assumePropsColor(Label)
```

export const YellowLabel1 = assumeProps(Label)({color: 'yellow'})

<fieldset>
<legend>assumePropsColor(Label)</legend>
<YellowLabel1 text="Hello World!" />
</fieldset>

By default, the `displayName` shown in React Dev Tools will be
`assumeColor(Label)`, because `Label` is the `displayName` of the base component
and we are partially applying a single prop called `color`.

The combinators in this library will let you set an optional `displayName` to
aid debugging, but having none, will try to compute a reasonable value from
their arguments.

To override the `displayName` _wrapper_ we can provide the second, optional
argument to `assumeProps`:

```tsx
import {assumeProps} from 'react-compinators'

const YellowLabel = assumeProps(Label)({color: 'yellow'}, 'Yellow')
//                                                       ↑
//                  Optional argument for displayName wrapper 

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // Yellow(Label)
```
export const YellowLabel2 = assumeProps(Label)({color: 'yellow'}, 'Yellow')

<fieldset>
<legend>Yellow(Label)</legend>
<YellowLabel2 text="Hello World!" />
</fieldset>

This is how it looks in React Dev Tools with a default `displayName`:

<img
  src="https://middle-ages.github.io/react-compinators-docs/docs/dev-tools-display-name-default.png"
  alt="Dev Tools default displayName"
  style={{border: '2px inset', maxWidth: '20rem'}}
/>

But when we provide the `Yellow` argument to `assumeProps` we get:

<img
  src="https://middle-ages.github.io/react-compinators-docs/docs/dev-tools-display-name-custom.png"
  alt="Dev Tools custom displayName"
  style={{border: '2px inset', maxWidth: '20rem'}}
/>

All combinators follow this pattern of taking an optional value that will
determine `displayName`.

#### 2. `assumeProp`

When you need to partially apply only a single prop, `assumeProp` is a simpler
variant of `assume`. Note that it takes an optional `displayName` argument as
well:

```tsx
import {assumeProp} from 'react-compinators'

const YellowLabel = assumeProp(Label, 'color')('yellow', 'My')

<YellowLabel text="Hello World!" />

console.log(YellowLabel.displayName) // My(Label)
```

export const YellowLabel3 = assumeProp(Label, 'color')('yellow', 'My')

<fieldset>
<legend>My(Label)</legend>
<YellowLabel3 text="Hello World!" />
</fieldset>

#### 3. `unfoldProp`

What if we wanted to partially apply _three_ variants of the button, one for
each color?
```tsx
import {assumeProp} from 'react-compinators'

export const GreenLabel  = assumeProp(Label, 'color')('green')
export const YellowLabel = assumeProp(Label, 'color')('yellow')
export const RedLabel    = assumeProp(Label, 'color')('red')

<RedLabel    text="Red"/>
<YellowLabel text="Yellow"/>
<GreenLabel  text="Green"/>
```

export const GreenLabel4 = assumeProp(Label, 'color')('green')
export const YellowLabel4 = assumeProp(Label, 'color')('yellow')
export const RedLabel4 = assumeProp(Label, 'color')('red')

<fieldset>
<legend>Calling <code>assumeProp</code> <i>three</i> times</legend>
<GreenLabel4  text="Green"/>
<YellowLabel4 text="Yellow"/>
<RedLabel4    text="Red"/>
</fieldset>

We could loop over the values, or we could use the `unfoldProp` combinator.
It supports the common use case of creating a _variant per union member_, useful
when we prefer _more components but fewer props_, over _fewer props but more
components_:
```tsx
import {String} from 'effect'
import {unfoldProp} from 'react-compinators'

const [ GreenLabel, YellowLabel, RedLabel ] = unfoldProp(
  Label,             // Base component.
  'color',           // Prop that we will be setting.
)(
  COLORS,            // Array of union members.
  String.capitalize, // Optional function will be used to compute variant
                     // displayName from its `color` prop.
) 

<RedLabel    text="Red"/>
<YellowLabel text="Yellow"/>
<GreenLabel  text="Green"/>

console.log(YellowLabel.displayName) // Yellow(Label)
```

export const [GreenLabel5, YellowLabel5, RedLabel5] = unfoldProp(
  Label, 'color',
)(
  COLORS,
  String.capitalize,
) 

<fieldset>
<legend><code>unfoldProp</code></legend>
<GreenLabel5  text="Green"/>
<YellowLabel5 text="Yellow"/>
<RedLabel5    text="Red"/>
</fieldset>

### Map

#### 1. `modProp`

`modProp` is used to map over a component prop without changing its type.The
returned component will be of the same type as the base component.

Useful for example to add a CSS class to the a component without creating a new
component, and without changing the component props at its call site. In this
case it would act like `assumeProp`, except instead of fixing a prop value, we
are _adding_ a fixed value to the prop.

Here we convert our label into one that appends a question mark to the text:

```tsx
import {String, pipe} from 'effect'
import {modProp} from 'react-compinators'

const QuestionLabel: typeof Label = pipe('?', String.concat, modProp(Label, 'text'))

<QuestionLabel color="yellow" text="Hello World" />

console.log(QuestionLabel.displayName) // mapPropText(Label)
```

export const QuestionLabel = pipe('?', String.concat, modProp(Label, 'text'))

<fieldset>
<legend><code>modPropText(Label)</code></legend>
<QuestionLabel color="yellow" text="Hello World" />
</fieldset>

#### 2. `mapProps`

`modProps` is actually a special case of `mapProps`, useful when:

1. You have a component that takes props of type `A`.
2. But you want a component that takes props of type `B`.
3. And the props you have are of type `B`.
4. But you do have some way of converting `B` ⇒ `A`.
 
 For example let's convert a component that display a number into a component
 that displays character count for a given string:
 
 ```tsx
 import {mapProps} from 'react-compinators'
 interface B { foo: string }
 interface A { bar: number }
 
 const ComponentA: FC<A> = ({ bar }) => <div>{bar.toString()}</div>;
 
 // The function mapping B ⇒ A
 const mapper = (a: B): A => ({ bar: a.foo.length })
 
 // We now have a component of B
 const ComponentB: FC<B> = pipe(ComponentA, mapProps(mapper));

 <ComponentB foo="Hello World!">
 ```
export const ComponentA1 = ({bar}) => <div>{bar.toString()}</div>
export const mapper1 = (a) => ({bar: a.foo.length})
export const ComponentB1 = pipe(ComponentA1, mapProps(mapper1))

<fieldset>
<legend><code>mapProps(ComponentA)</code></legend>
<ComponentB1 foo="Hello World!" />
</fieldset>

In this case we are renaming a prop and changing prop type, but `mapProps` can
do anything as long as the types fit.

#### 3. `mapProp`

When you don't need the full power of `mapProps`, map prop focuses on a single
named prop, and can only change its value but _not_ the prop name.

Here is the example of converting a component that displays numbers into one
that display character count, but here the prop name is the same between base
component and the one returned:

 ```tsx
 import {mapProp} from 'react-compinators'
 interface B { foo: string }
 interface A { foo: number }
 
 const ComponentA: FC<A> = ({foo}) => <div>{foo.toString()}</div>;
 const mapper = (foo: string): number => foo.length
 const ComponentB: FC<B> = pipe(ComponentA, mapProp(mapper, 'foo'));

 <ComponentB foo="Hello World!">
 ```
export const ComponentA2 = ({foo}) => <div>{foo.toString()}</div>
export const mapper2 = foo => foo.length
export const ComponentB2 = pipe(ComponentA2, mapProp(mapper2, 'foo'))

<fieldset>
<legend><code>mapProp(ComponentA)</code></legend>
<ComponentB2 foo="Hello World!" />
</fieldset>

#### 4. `omitProps`

When a parent component spreads its props to its children, there is usually some
prop massaging required. When this requires _removal_ of props by name, you can
convert your component into one that drops these props using `omitProps`.

In the code below, the `<Parent>` component takes a pair of props while its
child gets only a single prop. Instead of manipulating the props object, we
convert the child into one that ignores the extra prop:

```tsx
import {omitProps} from 'react-compinators'

interface ParentProps {text: string; number: number}
interface ChildProps {text: string}

const Child = ({text}: ChildProps) => <div>{text}</div>

const OmitNumber = omitProps(Child, 'OmitNumber')('number')

// No need to filter props: child is wrapped in a HOC that will
// discard the extra prop.
const Parent = (props: ParentProps) => (<OmitNumber {...props} >)

<Parent text="Hello World!" number={123} />
```

export const Child = ({text}) => <div>{text}</div>
export const OmitNumber = omitProps(Child, 'OmitNumber')('number')
export const Parent = (props) => (<OmitNumber {...props} />)

<fieldset>
<legend><code>Parent » OmitNumber(Child)</code></legend>
<Parent text="Hello World!" number={123} />
</fieldset>

### A note about `displayName`

`displayName` is used mostly for debugging via [React Dev
Tools](https://react.dev/learn/react-developer-tools). The convention for HOCs is:
```text
Original Component Name
            ↓   
   Yellow(Label)
      ↑
  HOC Name
```

Read more about React Dev Tools and HOCs
[here](https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#higher-order-components).

</Unstyled>